>>>Как вы реализовали асинхронное выполнение задач в вашем скрипте?

По задание необходимо было скачать содержимое репозитория в 3 асинхронные задачи. Интерпретировал это так, что нужно
распределить файлы репозитория на 3 загрузчика и ими скачивать их.

Используя API gitea получил данные о конкретной ветке, включая информацию о каждом файле. Из них извлек данные о путях к
каждому файлу и создал их список.

Распараллелил загрузку в 3 асинхронных загрузчика, которые качают отдельно по одному файлу (получаю их через API gitea),
для распределения файлов между загрузчиками использовал Очереди

Файлы сохранялись во временную папку, как требовало ТЗ. За асинхронную работу с файловой системой отвечала библиотека
aiofiles, за создание временной папки библиотека tempfile

После этого необходимо было посчитать у каждого файла хэш. Я реализовал все асинхронно похожим образом. Получил список
путей до всех файлов временной директории. Далее Очередь + 3 воркера. И наконец вывод названий файлов (путей) и их
хэшей в консоль через логгер

Для асинхронных запросов в сеть использовал библиотеку aiohttp. Во всем коде используется аннотация типов и логирование



>>>Какие библиотеки использовались для скачивания содержимого репозитория и для каких целей?

aiohttp - для асинхронных запросов в сеть
asyncio - для написания асинхронной логики работы скрипта



>>>Какие проблемы асинхронности вы сталкивались при выполнении задания и как их решали?

Проблема распределения нагрузки на 3 воркера. Решил через очередь.



>>>Как вы организовали скачивание файлов во временную папку?

Скачивал файл при помощи aiohttp сессии через API gitea, а далее полученные данные сохранял в бинарном виде на диск
через aiofiles. Временную папку создавал через библиотеку tempfile



>>>Какие основные требования wemake-python-styleguide вы находите наиболее важными для поддержания качества кода?

Сам постоянно пользуюсь линтером, но на мой вкус в данной конфигурации он слишком выкручен.
Мне кажется страдает качество кода, искусственно ограничивается функциональность языка.
(Например, запрет статик методов)
Не в порядке важности (!!!)
1. Организация импортов, их сортировка.
2. Аннотация типов
3. Документирование кода
4. Обработка конкретных исключений, без общих Exception
5. Нейминг переменных
6. Логгирование вместо print
7. Ограничение на использование f-string в логгере (Есть полезная статья по его работе)

На мой вкус излишние:
1. Ограничение длины строки в 80 символов. Заточено под маленькие устройства, лично мне это неудобно. Проблема
экстраполируется при длинных именах переменных (в целях улучшения читаемости)
2. Не всегда полезен единый стиль ковычек (JSON строчки, голые SQL запросы). Сюда же отнесу запятую последнюю WPS323
3. Запрет статик методов. Бессмысленное ограничение функциональности
4. Запрет к обращению к приватным методам классов в тестах.



>>>Какие инструменты использовали для измерения 100% покрытия тестами?

Библиотеку coverage. Через неё запустил pytest, сделал report, далее в удобном формате сформировал html.
coverage run -m -pytest
coverage report
coverage html



>>>Какие типы тестов вы написали для проверки функциональности вашего скрипта?
>>>(Например, модульные тесты, интеграционные тесты)

В основном модульные тесты. В них я мокал внешние зависимости и проверял, что методы работают корректно
при определенных входных данных, а также, что поведение предсказуемое при ошибках.
Написан также интеграционный тест для публичного метода для проверки асинхронной работы воркеров.



>>>Как вы тестировали асинхронный код? Использовали ли вы моки (mocks) или стабы (stubs) для тестирования
>>>асинхронных операций?

Асинхронный код тестировал через декоратор @pytest.mark.asyncio
Моки использовал - для симулирования результата выполнения функций и прочего, когда в контексте проверки метода, нужно
проверить именно его работу, а не работу вызовов методов внутри него. Для функций внутри других методов есть свои тесты.
Тесты покрывают 100% кода: как поведение функций при ошибках, так и при нормальной работе.
